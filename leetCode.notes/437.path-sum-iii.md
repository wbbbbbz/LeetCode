#### 0437的感想
- 参考：[17 ms O(n) java Prefix sum method - LeetCode Discuss](https://leetcode.com/problems/path-sum-iii/discuss/91878/17-ms-O(n)-java-Prefix-sum-method)
- 参考：[Simple Java DFS - LeetCode Discuss](https://leetcode.com/problems/path-sum-iii/discuss/91889/Simple-Java-DFS)
- 方法1：直接进行搜索
  - 与之前的搜索不一样，因为每个节点可能包括，可能不包括。
  - 这种情况可以对每一个节点进行搜索
  - 对每一个节点进行from该节点的搜索(就是之前的从根节点出发到任意节点是否为sum的搜索)
  - 然后再递归外层搜索函数
- 方法2：记录prefix sum
  - 不断记录从根节点到现在节点的路径和，放入map中。在计算完之后再减去
  - 然后从map中搜索sum-target的次数。因为sum是到该节点为止的路径和，如果sum-target存在，就说明以某个节点为根节点，到现节点之前的某一段路径刚好是target。
  - 因为之前节点的连续和是由两个路径和相减即可获得
  - 然后再对左右节点进行递归（每个节点作为根节点都考虑一下）
