"""
位运算题有套路：
1.拆位 -> 单独考虑每一个位
2.试填法 -> 逐位考虑构建答案，看看能不能最高位构建为0
3.如果有相邻合并的话就要从子数组考虑问题
从最高位考虑，如果某一段数字能合并成0，那么操作次数就是这段的长度-1（一定有一个0）
如果某一段数字不能合并成0，那么操作次数就是这一段的长度（需要从外部引入一个0）

如果整个数组都不能合并成0，那么cnt就会不断+1到n，但是题目限制k<n所以没有问题。计算出来的操作次数是n
"""
from typing import List

class Solution:
    def minOrAfterOperations(self, nums: List[int], k: int) -> int:
        ans = mask = 0 # mask -> 如果这一位要考虑标成1，否则标成0.只要&一下就可以得到需要考虑的位数了。之后的&的操作的时候每一个数字都要&一下mask
        for b in range(29, -1, -1): #最大数是2^30，也就是最多29位
            mask |= 1 << b
            cnt = 0 # 操作次数
            and_res = -1 # 用补码思考，所有位数都是1的数就是-1。这个就是用来&其他数的
            for x in nums:
                # 这个代码已经实现了从左到右的合并次数了。最后一个数不需要，如果还是1那就自然+1了
                and_res &= x & mask
                if and_res:
                    cnt += 1 # 合并x
                    if cnt > k:
                        break # 没问题
                else:
                    # 这一段合并完了
                    # 不加1就是代表-1了。准备合并下一段
                    and_res = -1
            if cnt > k:  # 答案的这个比特位不能是0
                ans |= 1 << b  # 答案的这个比特位置为1
                mask ^= 1 << b
        
        return ans
# 时间复杂度O(30n)